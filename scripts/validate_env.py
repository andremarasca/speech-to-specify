"""Validates environment configuration per §12 of Cláusulas Pétreas.

Scans for pydantic BaseSettings subclasses in the project, then:
  1. Generates/updates .env.example with all declared fields.
  2. Validates that .env contains all required variables.

Works with pydantic-settings v2+ (SettingsConfigDict/model_fields).
Falls back to pure-AST analysis if pydantic is not importable.

Usage:
    python scripts/validate_env.py [--config-module src.lib.config]
    python scripts/validate_env.py --ast-only [--config-file src/lib/config.py]

Exit codes:
    0 = all required env vars are present
    1 = missing required vars or config not found
"""

from __future__ import annotations

import ast
import sys
from pathlib import Path


# ── AST-based fallback (zero dependencies) ──────────────────────────


def _extract_fields_ast(config_file: Path) -> list[dict[str, str]]:
    """Parse a config file via AST to extract BaseSettings fields.

    Returns a list of dicts with keys: name, type, default, env_prefix.
    """
    try:
        source = config_file.read_text(encoding="utf-8")
        tree = ast.parse(source)
    except (SyntaxError, UnicodeDecodeError, OSError) as exc:
        print(f"[validate_env] Cannot parse {config_file}: {exc}")
        return []

    fields: list[dict[str, str]] = []

    for node in ast.walk(tree):
        if not isinstance(node, ast.ClassDef):
            continue

        # Check if it inherits from BaseSettings
        is_settings = any(
            (isinstance(base, ast.Name) and base.id == "BaseSettings")
            or (isinstance(base, ast.Attribute) and base.attr == "BaseSettings")
            for base in node.bases
        )
        if not is_settings:
            continue

        # Extract env_prefix from model_config if present
        env_prefix = ""
        for item in node.body:
            if isinstance(item, ast.Assign):
                for target in item.targets:
                    if isinstance(target, ast.Name) and target.id == "model_config":
                        if isinstance(item.value, ast.Call):
                            for kw in item.value.keywords:
                                if kw.arg == "env_prefix":
                                    if isinstance(kw.value, ast.Constant):
                                        env_prefix = str(kw.value.value)

        # Extract annotated assignments (fields)
        for item in node.body:
            if isinstance(item, ast.AnnAssign) and isinstance(item.target, ast.Name):
                field_name = item.target.id
                if field_name.startswith("_"):
                    continue

                field_type = ""
                if isinstance(item.annotation, ast.Name):
                    field_type = item.annotation.id
                elif isinstance(item.annotation, ast.Subscript):
                    field_type = ast.dump(item.annotation)

                has_default = item.value is not None
                default_str = ""
                if has_default and isinstance(item.value, ast.Constant):
                    default_str = repr(item.value.value)
                elif has_default:
                    default_str = "(computed)"

                env_var_name = f"{env_prefix}{field_name}".upper()

                fields.append(
                    {
                        "name": field_name,
                        "env_var": env_var_name,
                        "type": field_type,
                        "default": default_str,
                        "required": "no" if has_default else "yes",
                        "class": node.name,
                    }
                )

    return fields


# ── .env parsing ─────────────────────────────────────────────────────


def _parse_env_file(env_path: Path) -> set[str]:
    """Parse a .env file and return the set of defined variable names."""
    defined: set[str] = set()
    if not env_path.is_file():
        return defined

    for line in env_path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" in line:
            key = line.split("=", 1)[0].strip()
            defined.add(key)

    return defined


# ── .env.example generation ──────────────────────────────────────────


def _generate_env_example(fields: list[dict[str, str]], output: Path) -> None:
    """Generate .env.example from extracted fields."""
    lines: list[str] = [
        "# Auto-generated by scripts/validate_env.py",
        "# Do NOT edit manually — regenerate with: python scripts/validate_env.py",
        "",
    ]

    current_class = ""
    for field in fields:
        if field["class"] != current_class:
            if current_class:
                lines.append("")
            lines.append(f"# ── {field['class']} ──")
            current_class = field["class"]

        comment = ""
        if field["required"] == "yes":
            comment = "  # REQUIRED"
        elif field["default"]:
            comment = f"  # default: {field['default']}"

        lines.append(f"{field['env_var']}={comment}")

    output.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"[validate_env] Generated {output}")


# ── Main ─────────────────────────────────────────────────────────────


def main() -> int:
    config_file = Path("src/lib/config.py")
    args = sys.argv[1:]
    i = 0
    while i < len(args):
        if args[i] == "--config-file" and i + 1 < len(args):
            config_file = Path(args[i + 1])
            i += 2
        else:
            i += 1

    if not config_file.is_file():
        # Graceful skip if no config file exists
        print(f"[validate_env] Config file not found: {config_file}")
        print("[validate_env] SKIPPED — no configuration to validate.")
        return 0

    print(f"[validate_env] Analyzing {config_file} ...")

    fields = _extract_fields_ast(config_file)

    if not fields:
        print("[validate_env] No BaseSettings fields found.")
        return 0

    # Generate .env.example
    env_example = Path(".env.example")
    _generate_env_example(fields, env_example)

    # Validate .env
    env_file = Path(".env")
    defined_vars = _parse_env_file(env_file)

    required_fields = [f for f in fields if f["required"] == "yes"]
    missing = [f for f in required_fields if f["env_var"] not in defined_vars]

    print(
        f"[validate_env] Found {len(fields)} config fields "
        f"({len(required_fields)} required)."
    )

    if not env_file.is_file():
        print("[validate_env] WARNING — .env file not found.")
        if required_fields:
            print(
                f"[validate_env] {len(required_fields)} required var(s) "
                "need to be set (via .env or environment)."
            )
            for f in required_fields:
                print(f"  MISSING  {f['env_var']}  ({f['class']}.{f['name']})")
            return 1
        return 0

    if missing:
        print(
            f"[validate_env] FAILED — {len(missing)} required var(s) missing from .env:"
        )
        for f in missing:
            print(f"  MISSING  {f['env_var']}  ({f['class']}.{f['name']})")
        return 1

    print("[validate_env] PASSED — all required environment variables are set.")
    return 0


if __name__ == "__main__":
    sys.exit(main())
